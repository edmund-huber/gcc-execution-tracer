#include <fcntl.h>
#include <getopt.h>
#include <libgen.h>
#include <linux/limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "assert.h"
#include "decoder.h"
#include "scanning.h"

int nonce = 0;

// Reference: https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow .
char *x86_64_branching_inst[] = {
    // Unconditional jump.
    "jmp",
    // Jump based on status flags.
    "je", "jne", "jg", "jge", "ja", "jae", "jl", "jle", "jb", "jbe", "jo",
    "jno", "jz", "jnz", "js", "jns",
    // Conditional jump based on {,e,r}cx registers.
    "jcxz", "jecxz", "jrcxz",
    // Loop instructions.
    "loop", "loope", "loopne", "loopnz", "loopz",
    // Function call and return.
    "call", "ret",
    NULL
};

int execute_gas(char *input_fn, char *output_fn) {
    char command[128] = { 0 };
    snprintf(command, sizeof(command), "as --64 -o %s %s", output_fn, input_fn);
    return system(command);
}

int main(int argc, char **argv) {
    // Parse the command line.
    char *output_fn = NULL;
    int debug = 0;
    int is_64 = 0;
    int c;
    char *long_option_64 = "64";
    struct option long_options[] = {
        { long_option_64, no_argument, NULL, 0 },
        { 0, 0, 0, 0}
    };
    int long_index;
    while ((c = getopt_long(argc, argv, "d:gI:o:", long_options, &long_index)) != -1) {
        switch (c) {
        case 0:
            if (long_options[long_index].name == long_option_64) {
                is_64 = 1;
            }
            break;
        case 'g':
            debug = 1;
            break;
        case 'I':
            // Only here because we pass -I. to gcc and it passes that flag to
            // us too.
            break;
        case 'o':
            output_fn = optarg;
            break;
        default:
            ASSERT(0);
        }
    }

    // Check that we got the flags we were expecting.
    ASSERT(is_64);
    ASSERT(output_fn != NULL);

    // In addition to flags, we take one more option: the path to the assembler
    // file.
    ASSERT(optind == argc - 1);
    char *input_fn = argv[optind];

    // We also need GCC_TRACER_DECODER to be set to the filename to use for the
    // decoder file, otherwise let's just call gas directly.
    char *decoder_fn;
    if ((decoder_fn = getenv("GCC_TRACER_DECODER")) == NULL)
        return execute_gas(input_fn, output_fn);
    decoder_t *decoder = decoder_load(decoder_fn, 1);

    // Set up the temporary file that we will write the instrumented assembly
    // to, (which we'll later use gas to assemble).
    char temp_fn[] = "/tmp/XXXXXX";
    int temp_fd = mkstemp(temp_fn);
    ASSERT(temp_fd != -1);
    FILE *temp_f = fdopen(temp_fd, "w");

    // The following is the state of the parser, which works in a single pass:
    int first_line = 1;
    int do_instrument = 1;
    #define TRACE_CHUNK_MAX_LEN 1000
    id_t trace_chunk[TRACE_CHUNK_MAX_LEN] = { 0 };
    int trace_chunk_len = 0;
    enum {
        TRUSTFREE,
        TRUST_NEXT_LINE,
        TRUST_THIS_LINE
    } trust = TRUSTFREE;

    FILE *in_file = fopen(input_fn, "r");
    ASSERT(in_file != NULL);
    char line[1024];
    while (fgets(line, sizeof(line), in_file) != NULL) {
        ASSERT(strlen(line) > 0);
        ASSERT((line[strlen(line) - 1] == '\n') || feof(in_file));

        // Try to parse out a .file directive, they look like this:
        // 	.file	"pretzel.c"
        char *s = line;
        char source_fn[PATH_MAX];
        int found_file_directive =
            skip_exactly("\t.file\t\"", &s) &&
            scan_until_any("\"", &s, source_fn, sizeof(source_fn)) &&
            skip_exactly("\"\n", &s) &&
            *s == '\0';
        if (found_file_directive) {
            decoder_set_current_file(decoder, source_fn);
            goto done_with_line;
        } else {
            // Expecting the .file directive on the first line.
            ASSERT(!first_line);
        }

        // If we encounter "# as-tracer-do-not-instrument" then we'll turn off
        // instrumentation. (And the opposite.)
        s = line;
        if (skip_exactly("# as-tracer-do-instrument\n", &s))
            do_instrument = 1;
        else if (skip_exactly("# as-tracer-do-not-instrument\n", &s))
            do_instrument = 0;
        if (!do_instrument) {
            trace_chunk_len = 0;
        }

        // Try to parse out a comment generated by -fverbose-asm, they look
        // like this:
        // # pretzel.c:6:     if (argc != 2) {
        s = line;
        char found_source_fn[PATH_MAX] = { 0 };
        char found_line_no[32] = { 0 };
        char found_line[1024] = { 0 };
        int found_verbose_asm_comment =
            skip_exactly("# ", &s) &&
            scan_until_any(":", &s, found_source_fn, sizeof(found_source_fn)) &&
            skip_exactly(":", &s) &&
            scan_until_any(":", &s, found_line_no, sizeof(found_line_no)) &&
            skip_exactly(":", &s) &&
            scan_until_any("\n", &s, found_line, sizeof(found_line)) &&
            skip_exactly("\n", &s) &&
            *s == '\0';
        if (found_verbose_asm_comment) {
            // If this isn't the same source file called out in the .file
            // directive, then we are extremely confused.
            ASSERT(strcmp(decoder->current_file_name, basename(found_source_fn)) == 0);

            if (do_instrument) {
                int line_no = atoi(found_line_no);
                id_t line_id = decoder_add_line(decoder, line_no, found_line);

                // If we just saw this line, don't bother adding to the
                // trace_chunk.
                if ((trace_chunk_len == 0) || (trace_chunk[trace_chunk_len - 1] != line_id)) {
                    trace_chunk[trace_chunk_len++] = line_id;
                    ASSERT(trace_chunk_len < TRACE_CHUNK_MAX_LEN);
                }
            }

            goto done_with_line;
        }

        // We need to record and reset the trace_chunk, using the arch-specific
        // asm "record stub", whenever we come across ..
        //   * a "LABEL:" because if execution jumps here, it won't have
        //     executed the previous lines.
        s = line;
        int found_label =
            skip_exactly(".", &s) &&
            scan_until_any(":", &s, NULL, 0) &&
            skip_exactly(":\n\0", &s);

        // (continued)
        //   * any of the arch-specific jmp, call, ret, (etc) instructions that
        //     (might) change the instruction pointer, since this (might be) our
        //     last chance to record what has already been executed.
        s = line;
        int found_branch = 0;
        if (skip_exactly("\t", &s)) {
            for (int i = 0; x86_64_branching_inst[i] != NULL; i++) {
                if (skip_exactly(x86_64_branching_inst[i], &s)) {
                    found_branch = 1;
                    break;
                }
            }
        }

        // (continued)
        if ((found_label || found_branch) && (trace_chunk_len > 0) && do_instrument) {
            // Record the trace chunk.
            id_t chunk_id = decoder_add_chunk(decoder, trace_chunk, trace_chunk_len);

            // Copy the record stub over, with values substituted in.
            ASSERT(fputs("######## RECORD\n", temp_f) > 0);
            FILE *stub_f = fopen("arch/x86_64/record_stub.s", "r");
            ASSERT(stub_f != NULL);
            char stub_line[128];
            char stub_line_part[128];
            while (fgets(stub_line, sizeof(stub_line), stub_f) != NULL) {
                ASSERT(strlen(stub_line) > 0);
                ASSERT((stub_line[strlen(stub_line) - 1] == '\n') || feof(stub_f));

                char *stub_s = stub_line;
                while (scan_until_any("?", &stub_s, stub_line_part, sizeof(stub_line_part))) {
                    ASSERT(fputs(stub_line_part, temp_f) > 0);
                    ASSERT(skip_exactly("?", &stub_s));
                    ASSERT(scan_until_any("?", &stub_s, stub_line_part, sizeof(stub_line_part)));
                    if (strcmp(stub_line_part, "NONCE") == 0) {
                        fprintf(temp_f, "%i", nonce);
                    } else if (strcmp(stub_line_part, "TRACE_CHUNK_ID") == 0) {
                        fprintf(temp_f, "$%i", chunk_id);
                    } else {
                        ASSERT(0);
                    }
                    ASSERT(skip_exactly("?", &stub_s));
                }
                ASSERT(fputs(stub_s, temp_f) > 0);
            }
            nonce++;
            fclose(stub_f);
            ASSERT(fputs("######## END\n", temp_f) > 0);

            trace_chunk_len = 0;
            goto done_with_line;
        }

        // If we see a comment like "# trust-me-i-know-what-im-doing\n", we'll
        // allow the next line of assembly to reference r15.
        s = line;
        if (skip_exactly("\t# trust-me-i-know-what-im-doing\n", &s)) {
            trust = TRUST_NEXT_LINE;
        }

        // If we come across any use of the r15 register, then the -ffixed-r15
        // flag didn't work, and we can't continue.
        ASSERT((trust == TRUST_THIS_LINE) || (strstr(line, "%r15") == NULL));

    done_with_line:
        first_line = 0;
        switch (trust) {
        case TRUSTFREE: break;
        case TRUST_NEXT_LINE:
            trust = TRUST_THIS_LINE;
            break;
        case TRUST_THIS_LINE:
            trust = TRUSTFREE;
            break;
        }
        fputs(line, temp_f);
    }
    fclose(temp_f);

    // If we run past the end of the assembly source, and we have anything left
    // in 'trace_chunk', something has gone really wrong, because any
    // sensible assembly file should end with a 'ret' instruction ..
    ASSERT(trace_chunk_len == 0);

    // Use gas to assemble our instrumented assembly.
    int ret = execute_gas(temp_fn, output_fn);

    // Only clean up after ourselves if the debug flag isn't on.
    if (debug)
        printf("as-tracer done: input %s, output %s\n", input_fn, temp_fn);
    else
        unlink(temp_fn);

    return ret;
}
