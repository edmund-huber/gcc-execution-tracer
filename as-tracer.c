#include <getopt.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define ASSERT(cond) \
    { \
        if (!(cond)) { \
            printf("ASSERT(%s) failed at %s L%i\n", #cond, __FILE__, __LINE__); \
            exit(1); \
        } \
    }

#define NAME "as-tracer"

int skip_exactly(char *to_skip, char **s) {
    if (strncmp(*s, to_skip, strlen(to_skip)) == 0) {
        *s += strlen(to_skip);
        return 1;
    }
    return 0;
}

int scan_until(char c, char **s, char *scanned, int scanned_sz) {
    int ret = 0;
    int scanned_off = 0;
    for (; (**s != c) && (**s != '\0'); *s += 1) {
        if (scanned_off == scanned_sz) {
            return 0;
        }
        scanned[scanned_off++] = **s;
        ret = 1;
    }
    return ret;
}

// Reference: https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow .
char *x86_64_branching_inst[] = {
    // Unconditional jump.
    "jmp",
    // Jump based on status flags.
    "je", "jne", "jg", "jge", "ja", "jae", "jl", "jle", "jb", "jbe", "jo",
    "jno", "jz", "jnz", "js", "jns",
    // Conditional jump based on {,e,r}cx registers.
    "jcxz", "jecxz", "jrcxz",
    // Loop instructions.
    "loop", "loope", "loopne", "loopnz", "loopz",
    // Function call and return.
    "call", "ret",
    NULL
};

int main(int argc, char **argv) {
    // Parse the command line.
    char *output_fn = NULL;
    int is_64 = 0;
    int c;
    char *long_option_64 = "64";
    struct option long_options[] = {
        { long_option_64, no_argument, NULL, 0 },
        { 0, 0, 0, 0}
    };
    int long_index;
    while ((c = getopt_long(argc, argv, "o:", long_options, &long_index)) != -1) {
        switch (c) {
        case 0:
            if (long_options[long_index].name == long_option_64) {
                is_64 = 1;
            }
            break;
        case 'o':
            output_fn = optarg;
            break;
        default:
            ASSERT(0);
        }
    }

    // Check that we got the flags we were expecting.
    ASSERT(is_64);
    ASSERT(output_fn != NULL);

    // In addition to flags, we take one more option: the path to the assembler
    // file.
    ASSERT(optind == argc - 1);
    char *input_fn = argv[optind];

    // Set up the temporary file that we will write the instrumented assembly
    // to, (which we'll later use gas to assemble).
    char temp_fn[] = "/tmp/XXXXXX";
    int temp_fd = mkstemp(temp_fn);
    ASSERT(temp_fd != -1);
    FILE *temp_f = fdopen(temp_fd, "w");

    // The following is the state of the parser, which works in a single pass:
    // On the first line, we are expecting a .file directive.
    int expecting_file_directive = 1;
    char source_fn[128] = { 0 };
    int previous_line_no;
    char source_buffer[1024 * 1024];

    FILE *in_file = fopen(input_fn, "r");
    char line[128];
    while (fgets(line, sizeof(line), in_file) != NULL) {
        // We should have sized `line` to the longest single line that we can
        // receive, otherwise our parsing is wrong.
        ASSERT(strlen(line) > 0);
        ASSERT((line[strlen(line) - 1] == '\n') || feof(in_file));

        // Try to parse out a .file directive, they look like this:
        // 	.file	"pretzel.c"
        char *s = line;
        int found_file_directive =
            skip_exactly("\t.file\t\"", &s) &&
            scan_until('"', &s, source_fn, sizeof(source_fn)) &&
            skip_exactly("\"\n", &s) &&
            *s == '\0';
        if (found_file_directive) {
            printf(NAME ": instrumenting '%s'\n", source_fn);
            expecting_file_directive = 0;
            previous_line_no = -1;
            source_buffer[0] = '\0';
            goto parsed;
        } else {
            ASSERT(!expecting_file_directive);
        }

        // Try to parse out a comment generated by -fverbose-asm, they look
        // like this:
        // # pretzel.c:6:     if (argc != 2) {
        s = line;
        char found_source_fn[128] = { 0 };
        char found_line_no[32] = { 0 };
        char found_line[1024] = { 0 };
        int found_verbose_asm_comment =
            skip_exactly("# ", &s) &&
            scan_until(':', &s, found_source_fn, sizeof(found_source_fn)) &&
            skip_exactly(":", &s) &&
            scan_until(':', &s, found_line_no, sizeof(found_line_no)) &&
            skip_exactly(":", &s) &&
            scan_until('\n', &s, found_line, sizeof(found_line)) &&
            skip_exactly("\n", &s) &&
            *s == '\0';
        if (found_verbose_asm_comment) {
            // If this isn't the same source file called out in the .file
            // directive, then we are extremely confused.
            ASSERT(strcmp(source_fn, found_source_fn) == 0);

            // If this is the same line number as a verbose-asm comment that
            // we've already seen, just keep going.
            int line_no = atoi(found_line_no);
            if (line_no == previous_line_no)
                goto parsed;

            // Otherwise, let's add it to source_buffer.
            ASSERT(sizeof(source_buffer) > strlen(source_buffer) + strlen(found_line));
            ASSERT(snprintf(
                source_buffer + strlen(source_buffer), sizeof(source_buffer) - strlen(source_buffer),
                "# %i: %s\n", line_no, found_line
            ) < sizeof(source_buffer) - strlen(source_buffer));

            previous_line_no = line_no;
            goto parsed;
        }

        // If we come across a jmp, call, ret, (etc) -- any instruction that
        // causes the instruction pointer to change -- let's insert the "record
        // stub".
        s = line;
        skip_exactly("\t", &s);
        for (int i = 0; x86_64_branching_inst[i] != NULL; i++) {
            if (skip_exactly(x86_64_branching_inst[i], &s)) {
                fprintf(temp_f, "# RECORD: %s\n", source_fn);
                fprintf(temp_f, "%s\n", source_buffer);
                previous_line_no = -1;
                source_buffer[0] = '\0';
                break;
            }
        }

    parsed:
        fputs(line, temp_f);
    }
    fclose(temp_f);

    // If we run past the end of the assembly source, and we have anything left
    // in 'source_buffer', something has gone really wrong, because any
    // sensible assembly file should end with a 'ret' instruction ..
    ASSERT(strlen(source_buffer) == 0);

    // Use gas to assemble our instrumented assembly, (and clean up after
    // ourselves).
    char command[128] = { 0 };
    snprintf(command, sizeof(command), "as --64 -o %s %s", output_fn, temp_fn);
    int ret = system(command);
    unlink(temp_fn);

    return ret;
}
